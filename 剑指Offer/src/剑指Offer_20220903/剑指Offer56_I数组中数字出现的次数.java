package 剑指Offer_20220903;

public class 剑指Offer56_I数组中数字出现的次数 {
	/*
	 * 位运算特性:
	 * 		1. 任何相同的数字异或为0,,所以将0与数组内的所有元素遍历异或,就得到这两个数字的异或结果z = x ^ y;
	 * 		
	 */
    public int[] singleNumbers(int[] nums) {
    	//
    	int z = 0;
    	for (int i : nums) {
			z ^= i;
		}
    	//拿到异或值后怎么让其得到两个的实际值呢??
    	//我们根据异或特性得到x,y中至少有一个数的二进制包含1,否则都是0时会相等,所以必满足.
    	//我们通过一个辅助变量m来保存z中哪一位是不同的1,(我们保存不同的那个1).
        //举个例子：z = 10 ^ 2 = 1010 ^ 0010 = 1000,第四位为1.
        //我们将m初始化为1，如果（z为异或值代表x,y二进制不同值才为1 & m）的结果等于0说明z的最低为是0
        //我们每次将m左移一位然后跟z做与操作，直到结果不为0.不为0就找到了x ^ y时二进制的不同值1.
        //此时m应该等于1000，同z一样，第四位为1.
    	int m = 1;
    	while ((z & m) == 0) {//当z&m为1时停止
			//否则左移
    		m <<= 1;
		}
    	//我们遍历数组，然后将数组的值与这个两个数得到的额不同值m做与运算,得到结果异或运算肯定就是单独值此两个数 1&0=0; 1&1=1;
    	//例如对于数组：[1,2,10,4,1,4,3,3]，我们把每个数字跟1000做与操作，可以分为下面两组：
    	 //nums1存放结果为0的: [1, 2, 4, 1, 4, 3, 3]
    	//nums2存放结果不为0的: [10] (碰巧nums2中只有一个10，如果原数组中的数字再大一些就不会这样了)
        //此时我们发现问题已经退化为数组中有一个数字只出现了一次
        //分别对nums1和nums2遍历异或就能得到我们预期的x和y
    	int x = 0, y = 0;
        for(int i : nums) {
            //这里我们是通过if...else将nums分为了两组，一边遍历一遍异或。
            //跟我们创建俩数组nums1和nums2原理是一样的。
            if((i & m) == 0) x ^= i;
            else y ^= i;
        }
    	return new int[]{x, y};
    }
    
    
    public int[] singleNumbers1(int[] nums) {
    	//找到两个不同值异或
    	int z = 0;
    	for (int i : nums) {
			z ^= i;
		}
    	//找到两个不同值中的不同1保存
    	int m = 1;
    	while ((z & m) == 0) {
			m <<= 1;//此时m为不同1的那个二进制数
		}
    	int x = 0,y = 0;
    	for (int i : nums) {
			if ((i & m) == 0) {
				x ^= i;
			} else {
				y ^= i;
			}
		}
    	return new int[] {x,y};
    }
}
